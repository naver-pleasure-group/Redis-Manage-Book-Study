# Chapter 3

# Isolation & Lock

레디스에서의 Isolation(격리)과 Lock(락)은 데이터의 동시 접근과 변경을 관리하는데 중요한 개념입니다.

1. Isolation (격리):
   레디스는 기본적으로 단일 스레드로 동작하는 인메모리 데이터베이스입니다. 따라서 동시에 여러 클라이언트가 레디스에 접근하더라도, 레디스 자체에서 데이터 격리를 제공합니다. 이는 레디스가 요청을 순차적으로 처리하여 한 번에 하나의 요청만 처리하고 다른 클라이언트의 요청을 기다리는 방식으로 이루어집니다. 이로 인해 클라이언트는 레디스에 접근하는 동안 다른 클라이언트로부터의 영향을 받지 않고 안전하게 데이터에 접근할 수 있습니다.
2. Lock (락):
   레디스는 분산 환경에서의 데이터 접근과 변경을 지원하기 위해 락 메커니즘을 제공합니다. 여러 클라이언트가 동시에 동일한 데이터를 변경하려고 할 때, 락을 사용하여 데이터의 일관성을 유지할 수 있습니다. 주요한 락 메커니즘으로는 낙관적 락(Optimistic Locking)과 비관적 락(Pessimistic Locking)이 있습니다.
    - 낙관적 락(Optimistic Locking): 낙관적 락은 락 없이 작업을 수행하고, 작업을 완료하기 전에 해당 데이터가 다른 클라이언트에 의해 변경되었는지 확인하는 방식입니다. WATCH 명령을 사용하여 특정 키를 모니터링하고, EXEC 명령을 호출하기 전에 해당 키가 변경되지 않았는지 확인합니다. 데이터가 변경되지 않은 경우에만 작업을 완료하고, 그렇지 않은 경우에는 작업을 다시 시도하거나 에러 처리를 수행합니다.
    - 비관적 락(Pessimistic Locking): 비관적 락은 작업을 수행하기 전에 미리 해당 데이터를 락으로 잠그는 방식입니다. 레디스에서는 SETNX나 SETEX와 같은 명령을 사용하여 락을 구현할 수 있습니다. 이러한 락은 특정 시간 또는 작업 완료 시점까지 지속될 수 있으며, 다른 클라이언트가 해당 데이터를 변경하는 것을 방지합니다. 작업이 완료되면 락을 해제하여 다른 클라이언트가 해당 데이터에 접근할 수 있도록 합니다.

레디스의 격리와 락 메커니즘은 동시성을 제어하고 데이터의 안정성을 보장하는데 도움을 줍니다. 애플리케이션에 맞는 적절한 격리 수준과 락 방식을 선택하여 데이터 접근과 변경을 관리해야 합니다.

읽기 일관성과 데이터 공유를 위해 Data Sets(Key/Value) Lock을 제공합니다. 또한 트랜잭션 제어를 위해 Read Uncommitted 와 Read committed 타입 두가지 유형을 제공합니다.

빅데이터를 처리하기 위한 플랫폼에는 hadoop과 같은 파일 시스템 기반도 있지만 가장 기본적인 단위의 트랜잭션을 제어할 수 없기 때문에 데이터의 일관성과 공유 에 매우 제한적일 수밖에 없습니다. 이와 같은 문제점을 개선하기 위해 NoSQL이 있지만, 모든 NoSQL이 트랜잭션을 제어할 수 있는 것은 아닙니다. Redis는 락 매커니즘 중 Data-Sets Lock 레벨의 매커니즘을 제공합니다.

# CAS (Check and Set)

데이터 일관성과 공유(동일한 데이터를 동시 여러 명의 사용자가 수정, 삭제하는 경우 발생하는 충돌을 피하기 위한 기술, 동시성)를 위해서는 동시 처리가 발생할 때 차례를 보장하고 늦은 사용자에게 트랜잭션의 충돌이 발생했음을 인지할 수 있도록 하는 기술을 **CAS** 라고 표현합니다.

```bash
WATCH a  # 다중 트랜잭션이 발생하는지 여부를 모니터링 시작
MULTI    # 트랜잭션의 시작 

Set 1 jmjoo 
QUEUED   # 임시저장
Set 2 yhjoo 
QUEUED   # 임시저장
EXEC     # 트랜잭션 종료 
(error) EXECABORT Transaction discarded because of previous errors 
# 이미 다른 세션에서 변경한 데이터를 다시 변경하려고 했기 때문에 생긴 에러 
```

# Transaction (Commit & Rollback)

Redis에서 트랜잭션은 여러 명령을 한 번에 실행할 수 있는 기능으로 **MULTI**, **EXEC**, **DISCARD**, **WATCH** 명령을 중심으로 두 가지 중요한 보장을 제공합니다.

- 트랜잭션 내의 모든 명령은 직렬화되어 순차적으로 실행됩니다. 다른 클라이언트가 보낸 요청은 트랜잭션 실행 중간에 처리되지 않으며, 명령들이 단일 격리된 작업으로 실행됨을 보장합니다.
- EXEC 명령은 트랜잭션 내 모든 명령을 실행합니다. 따라서 클라이언트가 EXEC 명령을 호출하기 전에 서버와의 연결이 끊기면 어떤 작업도 수행하지 않지만, EXEC 명령어가 호출되면 모든 작업을 수행합니다. append-only 파일을 사용하는 경우 Redis는 트랜잭션을 디스크에 기록하기 위해 단일 write(2) 시스콜을 사용합니다. 그러나 Redis 서버가 크래시되거나 시스템 관리자에 의해 강제로 종료되는 경우 일부 작업만 기록될 수 있습니다. Redis는 재시작시 이 조건을 감지하고 오류로 종료됩니다. redis-check-aof 도구를 사용하여 부분 트랜잭션을 제거하고 서버를 재시작할 수 있습니다.

트랜잭션을 사용자가 직접 제어하는 방법입니다.

```bash
MULTI     # 트랜잭션 시작

Set 1 jmjoo
QUEUED    # 임시 저장
Set 2 yhjoo
QUEUED    # 임시 저장 

EXEC      # 트랜잭션 종료(COMMIT) 
1) (integer) 1
2) (integer) 2  # 응답 배열을 반환 
```

EXEC 명령어를 실행하면 한 트랜잭션 내 작업들을 저장하고 응답값을 배열로 반환합니다. 각 요소는 명령의 발행 순서와 동일하게 트랜잭션 내 단일 명령에 대한 응답값입니다.

### 트랜잭션 내부 오류

트랜잭션 중 명령이 실패하는 경우 두 가지 종류의 명령 오류가 발생할 수 있습니다.

1. EXEC가 호출되기 전 명령이 큐에 들어가지 못할 수 있습니다. 예로 명령이 구문적으로 잘못된 경우(인수 개수 오류, 잘못된 명령어 등) 또는 maxmemory 지시문을 사용해 메모리 한도를 설정하는 경우(Out Of Memory)
2. 명령이 실패한 경우, 잘못된 키 값으로 접근하는 상황같을 때 발생할 수 있습니다.

Redis 2.6.5 버전 이상인 경우 부터는 서버가 명령을 누적하는 동안 오류를 감지하여 EXEC 명령어를 실행하지 않고 중단하며 오류를 반환하고 트랜잭션은 폐기됩니다. 이전 버전에서는 모든 트랜잭션 내 명령을 수행한 후 오류를 한번에 반환했습니다.

EXEC 명령 이후 발생하는 오류는 특별한 방식으로 처리되지 않으며, 트랜잭션 내 모든 다른 명령이 실행되며 트랜잭션 중에 몇 개의 명령이 실패하더라도 멈추지 않고 끝까지 실행됩니다.

### rollback

레디스는 트랜잭션의 롤백을 지원하지 않습니다. 트랜잭션 롤백을 지원하는 것은 레디스의 간단함과 성능에 상당한 영향을 미칠 수 있기 때문입니다.

### 트랜잭션 취소

DISCARD 명령어를 통해 트랜잭션을 취소하면 이전 MULTI 명령으로 큐에 쌓아뒀던 모든 명령이 삭제되고, 이후 추가로 넣은 명령도 실행되지 않습니다. 따라서 트랜잭션 도중 중단되거나 오류가 발생하면 DISCARD 명령을 사용하여 트랜잭션을 취소하고 이전 상태로 되돌아갈 수 있습니다. 이는 트랜잭션이 아예 수행되지 않은 것과 달리, 트랜잭션의 중간 상태를 롤백하지 않고 그대로 유지하는 것을 의미합니다.

### CAS 를 이용한 낙관적 락

낙관적 락(Optimistic locking)과 체크 앤드 셋(CAS)동작을 이용한 레디스 트랜잭션에서는 WATCH 명령을 사용합니다. WATCH 된 키는 해당키의 변경 사항을 감지하기 위해 모니터링되며, 만약 EXEC 명령을 호출하기 전에 WATCH 된 키 중 하나라도 다른 클라이언트에 의해 수정되면, 전체 트랜잭션이 중단되며, EXEC 명령은 트랜잭션이 실패했음을 알리는 Null 응답을 반환합니다.

예를 들어 레디스에 INCR명령이 없다는 가정하에 키의 값을 1씩 원자적으로 증가시키는 기능이 필요한 경우

```bash
WATCH counter           # 키 "counter"를 모니터링 시작
val = GET counter       # 현재 키의 값을 가져옴
val = val + 1           # 값을 1만큼 증가시킴
MULTI                   # 트랜잭션 시작
SET counter $val        # 트랜잭션 내에서 키의 새로운 값을 설정
EXEC                    # 트랜잭션 실행
```

여기서 WATCH 와 EXEC 사이에 다른 클라이언트가 counter 키를 수정하지 않는다면, 트랜잭션을 성공적으로 완료되고, ‘counter’ 키 값은 1만큼 증가된 값으로 설정됩니다. 하지만 다른 클라이언트가 EXEC 명령을 호출하기 전에 ‘counter’ 키를 수정한다면, 트랜잭션은 중단됩니다. EXEC 명령은 트랜잭션이 실패했음을 나타내는 Null 응답을 반환합니다. 이 경우 다시 시도하는 것을 선택하거나 다시 시도 하기 전에 ‘counter’ 키를 WATCH하는 것으로 시작합니다. WATCH와 낙관적 락 접근 방식을 사용함으로써 동시 클라이언트가 서로 간섭하지 않고 원자성을 지키며 작업을 안전하게 수행할 수 있습니다.

### WATCH 명령어

WATCH 명령은 레디스 트랜잭션에서 조건부로 EXEC를 수행하도록 만드는 기능입니다. WATCH된 키가 수정(다른 트랜잭션, 클라이언트에서)되지 않은 경우에만 트랜잭션을 실행하도록 설정하는 것으로 클라이언트가 수행하는 쓰기 명령과 레디스 자체의 만료 또는 삭제 같은 수정 사항도 모두 감지할 수 있습니다. 만약 WATCH 된 키가 WATCH 되기 시작한 후 EXEC를 수신하기 전에 수정(다른 트랜잭션에서)되었다면 전체 트랜잭션을 중단합니다.

WATCH는 여러번 호출이 가능합니다. 모든 WATCH 호출은 호출 시점부터 EXEC가 호출되기 까지 변경사항을 감시하는 효과를 가지며 하나의 WATCH 호출에 임의의 개수의 키를 보낼 수 있습니다. EXEC가 호출되면 모든 키가 UNWATCH됩니다. 트랜잭션 중단여부와 상관없고, 클라이언트 연결이 닫힐 때도 모든 키가 UNWATCH됩니다.

## Index 유형 및 생성

### Forward Index (전진 인덱스)

전진 인덱스는 문서의 필드에 저장된 값을 기반으로 키-값 쌍을 저장하는 인덱스입니다. 예를 들어, 사용자의 이름을 키로 하고 사용자 정보를 저장하는 것이 전진 인덱스의 예입니다. Forward Index는 문서 내용을 저장하고, 해당 필드 값을 키로 사용하여 문서에 대한 검색을 수행합니다.

### Inverted Index (역진 인덱스)

역진 인덱스는 용어를 문서에 대한 위치로 매핑하는 인덱스입니다. 특정 용어가 어떤 문서에 어떤 위치에서 등장하는지를 기록하여 특정 용어에 대한 검색을 빠르게 수행할 수 있게 합니다. 예로 검색 엔진에서는 단어를 역진 인덱스로 저장하여 해당 단어가 어떤 문서에서 나타나는지 빠르게 파악할 수 있습니다.

Redis는 Forward Index를 사용해 문서 내용을 저장하고, Inverted Index를 사용하여 용어를 문서 위치로 매핑합니다. 이를 통해 Redis는 다양한 종류의 검색과 질의를 빠르고 효율적으로 처리합니다. 특정 키가 있는지 확인하는 용도로 해시 테이블을 사용하는데, O(1)의 시간복잡도로 특정 키가 있는지 판단할 수 있습니다.

Redis는 기본적으로 하나의 Key와 한개 이상의 Field/Element 값으로 구성되는데 해당 key에는 빠른 검색을 위해 기본적으로 인덱스가 생성됩니다. 이를 Primary key Index 라고 합니다. 그리고 사용자의 필요에 따라 추가적인 인덱스를 생성할 수 있는데 이를 Secondary Index 라고 합니다.

인덱스 키를 통해 검색할 때 유일한 값인 경우 Exact Match By a Secondary Index라고 하며
일정 범위의 값을 검색 조건으로 부여하는 경우를 Range By Secondary Index 라고 표현합니다.