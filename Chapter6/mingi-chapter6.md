# 복제 & 분산 시스템 개요

Redis에서 스케일 아웃 기능으로 파티셔닝을 제공하는데 대표적인 데이터 분산 처리시스템입니다. 기존의 관계형데이터베이스에서도 데이터 분산처리를 위해 스트라이핑(Striping)과 파티셔닝(Partitioning) 기법을 제공했지만 이는 하나의 논리적 데이터 구조인 테이블을 여러 개의 물리적 디스크 장치에 분산 저장하는 개념입니다. 이와 같이 하나의 서버 내에서 시스템 자원을 최대한 확장하여 데이터를 저장,관리 하는 기술을 스케일-업 이라 하며 여러 대의 서버로 분산 저장하는 개념을 스케일-아웃 이라고 합니다.

## 자원 공유

하나의 서버에서 사용할 수 있는 시스템 자원(CPU, Memory, Disk)은 매우 제한적인데 초당 5~10만 건 이상의 데이터가 일시적으로 발생하게 되면 순간적인 과부하가 발생하게 됩니다. 이 경우 하나의 서버 자원으로는 이를 한 번에 처리할 수 없지만 다른 서버의 자원을 함께 활용할 수 있다면 동시에 빠른 처리가 가능합니다.

## 성능 향상

하나의 서버에 지속적인 쓰기 작업을 수행할 때 해당 서버가 이를 처리할 수 있는 용량에 한계가 있습니다. 이 때 다른 서버에 데이터를 분산하여 저장하는 것을 로드밸런싱(Load Balancing)이라고 합니다.

## 안정성

데이터를 여러 대의 서버에 분산 저장하는 방법을 통해 빅데이터의 빠른 쓰기와 읽기가 가능하지만 만약 특정 서버에 예기치 못한 장애가 발생하게 된다면 데이터 처리 도중에 데이터가 유실될 수 있습니다. 이와 같은 현상이 발생하더라도 안전하게 데이터를 복구할 수 있어야 하는데 이를 위한 솔루션이 복제 시스템입니다. 복제 서버는 분산 서버에 장애가 발생하는 경우 실시간으로 데이터를 복제해 두었다가 대체하여 동작하는 서버입니다.

Redis 서버는 마스터-슬레이브(Master-Slave), 마스터-슬레이브-센티널(Master-Slave-Sentinel), 파티션 클러스트(Partition Cluster) 기능을 통해 데이터를 복제하고 분산 처리할 수 있다.

# Partition 유형

### 범위 파티션

분산 서버는 최소 2대부터 운영이 가능하지만 3대 이상의 서버를 권장한다. 한 서버가 장애가 발생한 경우 나머지 2대의 서버로 분산 처리가 가능하기 때문인데, 최초 서버 대수를 몇 대로 구축할 것인지 결정하는 것은 범위 파티션 방식에서 매우 중요한데 그 이유는 특정 범위의 키-값을 어느 서버에 저장할 것인지를 사용자가 사전에 결정해야 하기 때문에 서버의 대수에 따라 저장되는 위치가 결정되기 때문이다. Redis 서버에 저장되는 Key 값을 기준으로 특정 범위의 데이터들을 특정 파티션 서버로 분산 저장해 주는 개념

### 해시 파티션

장점은 사용자가 지정한 서버로 특정 범위 값을 저장할 수 있다는 것인데, 이 경우 사용자가 직접 설계하다 보면 각 분산 서버에 저장되는 데이터 양과 분산 정도가 현저히 떨어지는 경우가 발생할 수 있습니다. 예로 첫 분산 서버에는 데이터가 80만건 저장되고, 두 번째 분산서버에는 10만건, 세번째 분산 서버에는 30만건 저장되는 상태가 발생할 수 있다는 것이다. 해시 파티션은 Hash Algorithm에 의해 총 120만건의 데이터를 각 서버 당 40만건씩 골고루 분산 저장해주는 개념

## Partition 구현 방법

파티셔닝에는 3가지 방법이 있다.

### Client Side Partitioning

여러 대의 분산 서버를 구축할 때 각 서버에 저장될 데이터의 성격과 데이터 양을 사용자가 직접 설계하고 결정하는 방법으로 가장 원초적인 분산방법이지만 가장 정확하기도 하다. 일반적인 데이터 분산은 서버에서 제공하는 자동화 매커니즘에 의해 사용자의 의도와 관계없이 특정 서버로 저장되기 때문에 사용자가 개입할 수 없다. 사용자가 분산 기술 및 설계 능력이 부족한 경우 효과적이지만 의도대로 설계하고 싶은 경우 불편할 수 있다.

### Proxy Assisted Partitioning

분산 서버 외에 별도로 Proxy Server를 추가해 사용자가 대량의 데이터를 입력할 때 어떤 분산 서버로 보낼 지 효율과 의도에 대해 고민할 필요가 없이 Proxy Server에서 현재 분산 서버의 모든 상태 정보를 수집 및 저장해주며 사용자가 대량의 데이터에 대한 저장을 요구하는 경우 가장 적절한 분산 서버를 찾아서 저장한다. 또한 조회를 한다면 해당 데이터가 있는 서버의 정보를 분석한 후 데이터 결과를 반환한다.

### Query Routing

해시 파티션으로 데이터를 분산 저장해 주며 특정 분산 서버에 장애가 발생한 경우 사용 가능한 Slave 서버를 통해 지속적인 읽기 작업이 가능하고 가능한 서버로 자동 전환(Redirection)해 주는데 오픈소스로 제공하는 redis-rb 또는 predis 솔루션등을 이용해 구현할 수 있다.

<aside>
💡 **Redis Partition 의 단점**
1. Redis Server 환경에서 partitioning 기능을 이용한 분산 처리 기술의 사용은 적극적으로 권장하지 않는다. 데이터 세트가 여러 개의 인스턴스에 동시에 저장되어 있는 경우 이를 효과적으로 처리하고 트랜잭션 제어까지 수행하는 것은 결코 쉬운 작업이 아니며 이를 완벽히 지원하지 않는다.
2. 새로운 노드를 추가하고 기존 노드를 실 시간으로 제거하는 작업은 하나의 큰 파티션 영역을 새롭게 분할하고 합병하는 작업이 빈번하게 요구되는데 이 경우 RDB와 AOF파일을 백업하고 이전해야 하기 때문에 쉬운방법이 아님
3. 런타임 시 노드 추가와 제거 작업이 수행되는 단계에서 전체 서버의 균형을 맞추기 위한 Re-Balancing 작업을 수행해야 하는데 이를 처리하다 보면 성능 지연 문제 및 예기치 못한 기술적 한계가 발생할 수 있다.

</aside>



## Master & Slave & Sentinel

### 1. 마스터-슬레이브 복제 시스템

사용자의 데이터를 처리하는 마스터 서버 1대에 슬레이브 서버는 마스터 서버의 데이터를 실시간으로 복제하며 마스터 서버에 의해서만 쓰기 작업을 수행할 수 있고 사용자는 오직 읽기 작업만 수행 가능하다. 마스터 서버에 장애가 발생하면 슬레이브 서버가 자동으로 마스터 서버로 자동 전환(Fail Over)되지 않으며 사용자는 슬레이브 서버에 복제된 데이터를 이용하여 마스터 서버를 복구할 수 있다. 마스터 서버에 장애가 발생해도 슬레이브 서버에서 읽기 작업은 수행가능하다.

### 2. 마스터-슬레이브-센티널 복제 시스템

위에 마스터-슬레이브 복제에서처럼 마스터 서버에 장애가 나도 슬레이브 서버가 읽기 작업을 할 수 있지만, 쓰기 작업은 하지 못하기 때문에 일시적인 서비스 중단이 발생할 수 있다. 이를 해결하기 위해 슬레이브 서버를 마스터 서버로 전환시켜 지속적인 쓰기 및 읽기 작업이 가능하도록 해야한다. 이를 위해 센티널 서버를 추가로 구축한다. 센티널 서버는 일상적인 업무 환경에서는 마스터 서버와 슬레이브 서버를 지속적으로 모니터링 하다가 마스터 서버에 장애가 감지되면 슬레이브 서버를 즉시 마스터 서버로 자동 전환시켜 데이터 유실이 발생하지 않도록 Fail-Over 해준다. 센티널 서버는 사용자의 데이터를 수집하지 않고 오로지 마스터와 슬레이브 서버의 장애 상태만을 모니터링 한다.

센티널 서버란?

- 원본 데이터 서버에 예기치 못한 장애가 발생한 경우 데이터가 유실되는 치명적인 상태가 발생할 수 있다, 이와 같은 현상이 발생해도 언제든지 서비스를 수행하기 위해 슬레이브 서버는 자동 FailOver 해주는 기능이 필요
- 마스터 서버와 슬레이브 서버가 어떤 상태인지 거의 실시간으로 HeartBeat를 통해 감시하고 관련 정보 제공
- 데이터 서버에 어떤 장애가 발생하는 경우 문자 메세지 또는 이메일등을 통해 관련 상태 정보를 사용자에게 전달할 수 있다.

## 장애처리 방법

센티널 서버가 장애를 인지하고 FailOver 하는 절차에 대한 설명

1. 센티널 서버는 매 초마다 HeartBeat를 통해 Master 서버와 Slave 서버가 작동중인지 여부를 확인하며, 만약 일정 타임아웃동안 더 이상 응답이 없으면 장애가 발생한 것으로 간주하는데 이를 주관적 다운(Subjectively Down)이라고 하며 로그 파일에 “+sdown” 상태로 표기된다.
2. 주관적 다운은 하나의 센티널 서버가 장애 상태를 인지한 경우이며 만약 센티널 서버가 여러 대인 경우 모든 센티널 서버가 장애 상태를 인지한다면 이를 객관적 다운(Objectively Down)이라고 하며 “+odown” 으로 로그 파일에 표기된다. 센티널 서버는 Master 서버가 다운된 경우 다른 센티널 서버와 함께 전체 정족수(Quorum)를 확인한 다음 이에 미치지 못한 경우 최종적으로 실제 다운되었다고 판단한다.
3. 주관적 다운과 객관적 다운이 최종 확인되면 장애조치 작업을 단계별로 수행한다.
    1. 여러 대의 센티널 서버로 구축된 경우 센티널 리더를 선출해야하는데 이를 내부에서 선출과정을 반복적으로 수행해 리더를 선출
    2. 리더로 결정된 센티널 서버는 장애가 발생한 Master 서버를 대신할 Slave 서버를 선정
    3. 선정된 Slave 서버는 최종 Master 서버로 승격
    4. 남은 Slave 서버가 새로운 Master 서버를 모니터링 하도록 명령을 수행
    5. 모든 작업이 완료되면 센티널 서버 정보를 갱신하고 장애 복구 작업을 종료

## 부분 동기화

1. Master 서버 1대, Slave 서버 2대로 구성된 복제 서버환경에서 Master 서버에 장애가 발생하는 경우 새로운 Master 서버 데이터를 Slave 서버는 복제합니다.
2. 이 경우 Slave 서버는 이전 복제 데이터는 제거하고 새로운 Master 서버로부터 모든 데이터를 Full Sync 동기화
3. 4.0부터는 부분 동기화를 Partial Resync 작업 수행
4. 동기화해야 할 부분 데이터의 크기가 repl-backlog-size 파라미터보다 큰 경우 Full Sync 수행

분산 시스템에서 Master 서버에 장애가 발생하면서 데이터가 유실되지 않도록 방지하기 위해 실시간 동기화가 필요한데, 실제 동기화해야 할 데이터가 적은 경우 불필요한 작업이 반복되지 않도록 부분 동기화 작업이 가능하다. 이를 위해 redis4.0버전 이상부터는 repl-backlog-size 파라미터를 제공한다.

# Redis Cluster 구축 및 운영

클러스터는 파티셔닝을 통한 데이터를 분산 서버마다 복제 서버를 함께 구축 운영하기 위해 데이터 분산 처리를 위한 파티셔닝 시스템과 안정성 확보를 위한 복제 시스템을 말한다. 클러스터 환경에서는 센티널 서버가 요구되지 않는다.

클러스터 시스템을 구축하는 방법은 두 가지가 있는데, 하나는 Redis Cluster 명령어를 사용해 사용자가 직접 수동 설정하는 방법이며, 두 번째 방법은 redis-trib.rb 유틸리티를 사용해 자동 설정하는 방법이다.

1. Redis Cluster 명령어 방법 : 사용자가 직접 물리적 설계, 최적화된 클러스터 구축가능, 장애 발생 시 관리자의 의도대로 대응가능
2. Redis-trib.rb 유틸리티 자동설정 : 자동화된 알고리즘을 통해 클러스터 구축가능, 구축 및 운영관리에 대해 기술적 이해가 부족해도 구현가능, 장애 발생 시 자동화 알고리즘을 통해 시스템 재구성 수행

### 주요 특징

- 하나의 Master 또는 두 대의 Master 서버 환경으로 구축할 수 있지만 분산과 복제를 기반으로 하는 클러스터 서버 구축이 목적이므로 최소 3대의 Master 서버를 통해 데이터를 분산 저장하면서 각 서버의 장애를 대비하기 위해 Slave 서버를 통해 복제 시스템 구축을 목표로 해야하지만, 데이터를 분산 저장하는 목적은 초당 10만건 이상의 데이터를 빠르게 저장하는 것이 목적인데 만약 하나의 서버에 장애가 발생하면 분산 처리할 수 없게 되므로 Master 서버는 3 대가 권장된다.
- NoSQL 분야의 분산/복제 클러스터 환경은 위와같이 Master 서버 1대와 Slave 서버 1대가 각각 매핑되는 환경으로 제공되지만 반드시 Master와 Slave를 1:1로 매핑할 필요는 없다.
- Cluster 명령어를이용한 수동 설정은 사용자가 직접 설계하고 설치하기 때문에 Master 서버와 Slave 서버를 균형 맞게 구축할 수 있지만 유틸리티 설치로 인한 자동설정은 의도대로 구축할 수 없는 경우가 발생함

# Redis Cluster 장애 복구

### Master/Slave Failover & AutoSwitch

분산/복제 시스템의 가장 큰 장점은 어떠한 장애가 발생해도 데이터 안정성을 최대한 보장한다는 점이다. 이와 함께 장애 발생 시 Slave 서버는 Master 서버의 장애 상태를 인지하고 빠른 시간내 Master서버로 FailOver되어야 한다.

# Client for Redis

### Jedis, Redisson, Lettuce

Java등 프로그래밍언어 단에서 Redis에 접속해 데이터를 처리할 수 있는 오픈소스 API

# Logging & Monitoring

### Logging

레디스 내에서 발생하는 다양항 상태 정보를 얼마나 구체적이고 자세하게 수집할 것인지를 loglevel 파라미터를 통해 사용자가 결정할 수 있으며 수집된 정보는 logfile 파라미터를 통해 사용자가 원하는 경로에 원하는 이름으로 저장할 수 있다.

# Subscribe & Publish

레디스는 서버와 클라이언트간에 메시지를 송수신할 수 있는 기능을 통해 효율적인 데이터베이스 운영 관리가 가능하도록 메시지를 송신하는 Subscribe와 수신하는 Publish 명령어를 제공한다.

- subscribe 는 클라이언트로부터 해당 channel로 보낸 메시지를 푸시한다.
- 하나 이상의 channel에 가입한 클라이언트는 channel을 해제할 수 있지만 메시지를 내보내는 명령을 실행할 수 없다.
- subscribe 명령어를 실행하면 일관된 메시지 스트림을 수행할 수 있다.
- unsubscribe 명령어는 메시지 수신을 취소한다.
- publish/subscribe 는 키-밸류 저장공간과 관련없이 전송,수신 데이터는 어떤 기능이든 방해받지 않도록 독립적으로 설계됨
- psubcribe는 특정 패턴의 메시지만 수신하도록 설정